# ===============================================================================================================#
# Copyright 2024 Infosys Ltd.                                                                                    #
# Use of this source code is governed by Apache License Version 2.0 that can be found in the LICENSE file or at  #
# http://www.apache.org/licenses/                                                                                #
# ===============================================================================================================#

import argparse
import json
import os
import sys
import uuid
import time
from typing import List
import infy_fs_utils
from ..common._internal.processor_helper import ProcessorHelper
from ..data import (ControllerRequestData,
                    ControllerResponseData, ProcessorFilterData,
                    ProcessorResponseData, MessageCodeEnum)
from ..common import Constants, PydanticUtil
from ..common._internal.snapshot_util import SnapshotUtil
from ._internal.b_controller import BController
from ..interface import IControllerCLI


class ControllerCLI(BController, IControllerCLI):
    """Controller to receive request via CLI"""

    __fs_handler: infy_fs_utils.interface.IFileSystemHandler = None
    __request_file_path = None

    def __init__(self):
        super().__init__()
        self.__fs_handler = infy_fs_utils.manager.FileSystemManager(
        ).get_fs_handler(Constants.FSH_DPP)
        self.__start_time = None
        self.__message_info = None
        self.__internal_orchestrator = None

    def receive_request(self, internal_orchestrator=True) -> ControllerRequestData:
        """
        Receive request via CLI argument containing path of request file.

        Args:
            internal_orchestrator (bool, optional): Flag to indicate if internal orchestrator is used. Defaults to True.

        Returns:
            ControllerRequestData: The controller request data.
        """
        logger = self._get_logger()
        self.__internal_orchestrator = internal_orchestrator

        if not internal_orchestrator:
            processor_name, input_config_file_path, prev_proc_response_file_path_list = self.__get_data_from_cli()

            controller_request_data = ControllerRequestData()
            if len(prev_proc_response_file_path_list) == 0:
                request_group_num = f"R-{str(uuid.uuid4())[24:]}"
                # processor_num = f"{idx+1:03d}"
                processor_num = '001'
                request_id = f"{request_group_num}-{processor_num}"
                prev_proc_records_list = []
            else:
                # Read prev_proc_response_file_path and get request_id from it increment 001 to 002 and so on,
                # get record list as is ,change processor_filter var in to next proc name
                # dpp_version back to 0.0.0
                # "description": "Auto-generated by DPP orchestrator",
                # logic to consolidate list of pre_processor reponse data files
                snapshot_util = SnapshotUtil()
                controller_response_data, processor_response_data_list = \
                    snapshot_util.consolidate_controller_response_data(
                        prev_proc_response_file_path_list)
                prev_proc_response_file_path = snapshot_util.save_controller_response_data(
                    controller_response_data)
                print("prev_proc_response_file_path",
                      prev_proc_response_file_path)

                prev_proc_response_data_dict = json.loads(
                    self.__fs_handler.read_file(prev_proc_response_file_path))
                prev_proc_response_data = ControllerResponseData(
                    **prev_proc_response_data_dict)
                prev_request_id = prev_proc_response_data.request_id
                processor_num = f"{int(prev_request_id[-3:])+1:03d}"
                input_config_file_data = json.loads(
                    self.__fs_handler.read_file(input_config_file_path))
                processor_list = input_config_file_data.get('processor_list')
                for processor in processor_list:
                    if processor.get('processor_list'):
                        for inner_idx, inner_processor in enumerate(processor.get('processor_list')):
                            if inner_processor.get('processor_name') == processor_name:
                                processor_num = processor_num + \
                                    f".{inner_idx+1:03d}"
                                break

                request_group_num = prev_proc_response_data.request_id[:-4]
                # f"{int(prev_proc_response_data.request_id[-3:])+1:03d}"
                request_id = f"{request_group_num}-{processor_num}"
                # print("request_id", request_id)
                prev_proc_records_list = prev_proc_response_data.records
                # print("prev_proc_records_list", prev_proc_records_list)

            self.__message_info = f"Processor #{processor_num} | {request_id} | {processor_name}"
            logger.info(self.__message_info + " | Started")
            self.__start_time = time.time()

            controller_request_data.request_id = request_id
            controller_request_data.processor_filter = ProcessorFilterData()
            controller_request_data.processor_filter.includes.append(
                processor_name)
            controller_request_data.input_config_file_path = input_config_file_path

            SNAPSHOT_FOLDER_PATH = Constants._ORCHESTRATOR_SNAPSHOT_PATH
            self.__fs_handler.create_folders(SNAPSHOT_FOLDER_PATH)

            controller_request_data.snapshot_dir_root_path = SNAPSHOT_FOLDER_PATH
            if prev_proc_records_list:
                controller_request_data.records = prev_proc_records_list

            controller_request_file_path = f'{os.path.dirname(SNAPSHOT_FOLDER_PATH)}'
            controller_request_file_path += f'/{controller_request_data.request_id}'
            controller_request_file_path += f'{Constants._CONTROLLER_REQUEST_FILE_NAME_SUFFIX}'
            print("controller_request_file_path", controller_request_file_path)

            controller_request_data_json = json.loads(PydanticUtil.get_json_str(
                controller_request_data, indent=4))
            data_as_json_str = json.dumps(
                controller_request_data_json, indent=4)
            self.__fs_handler.write_file(
                controller_request_file_path, data_as_json_str, encoding='utf-8')

            sys.argv = [sys.argv[0]]
            sys.argv.extend(
                ['--request_file_path', controller_request_file_path])

            # pass

        request_file_path = self.__get_request_file_path_from_cli()
        request_file_data = json.loads(self.__fs_handler.read_file(
            request_file_path))
        controller_request_data = ControllerRequestData(
            **request_file_data)
        self.__request_file_path = request_file_path
        return controller_request_data

    def send_response(self, controller_response_data: ControllerResponseData) -> any:
        """
        Send response as a console statement containing path of response file.

        Args:
            controller_response_data (ControllerResponseData): The controller response data.

        Returns:
            str: Path of the response file.
        """
        logger = self._get_logger()
        request_file_path = self.__request_file_path
        response_file_path = self.__generate_response_file_name(
            request_file_path)

        data_as_json_str = PydanticUtil.get_json_str(
            controller_response_data, indent=4)
        self.__fs_handler.write_file(
            response_file_path, data_as_json_str, encoding='utf-8')
        server_exception_message_list = []
        processor_response_data_list: List[ProcessorResponseData] = SnapshotUtil(
        ).create_processor_response_data_list(controller_response_data)
        for processor_response_data in processor_response_data_list:
            server_exception_message_list.extend(ProcessorHelper.get_messages(
                processor_response_data, MessageCodeEnum.SERVER_ERR_UNHANDLED_EXCEPTION))
        if not self.__internal_orchestrator:
            elapsed_time = round((time.time() - self.__start_time), 4)
            start_time_dt = time.strftime("%H:%M:%S", time.localtime(
                self.__start_time)) + f".{int((self.__start_time % 1) * 1000):03}"
            message_start_time = f"Start time: {start_time_dt}"
            message_elapsed_time = f"Execution time: {elapsed_time} secs"
            logger.info(
                self.__message_info + " | Completed | " + message_start_time + " | " + message_elapsed_time)
        if server_exception_message_list:
            print('status=failure')
        else:
            print('status=success')
        print("response_file_path=" + response_file_path)
        return response_file_path

    # --------- Private Methods -------------

    def __get_request_file_path_from_cli(self) -> str:
        parser = argparse.ArgumentParser()
        parser.add_argument("--request_file_path", default=None, required=True)
        # args = parser.parse_args()

        # Python
        args, _ = parser.parse_known_args()

        request_file_path = args.request_file_path
        return request_file_path

    def __get_data_from_cli(self) -> str:
        parser = argparse.ArgumentParser()
        parser.add_argument("--processor_name", default=None, required=True)
        parser.add_argument("--input_config_file_path",
                            default=None, required=True)
        parser.add_argument("--prev_proc_response_file_path",
                            default=None, required=True)
        for i in range(2, 10):
            parser.add_argument(f"--prev_proc_response_file_path_{i}",
                                default=None, required=False)

        args = parser.parse_args()
        processor_name = args.processor_name
        input_config_file_path = args.input_config_file_path
        prev_proc_response_file_path_list = []
        for arg in vars(args):
            if arg.startswith('prev_proc_response_file_path'):
                if getattr(args, arg) and getattr(args, arg).lower().strip('\'"') not in ("", 'null'):
                    prev_proc_response_file_path_list.append(
                        getattr(args, arg))

        return processor_name, input_config_file_path, prev_proc_response_file_path_list

    def __generate_response_file_name(self, request_file_path):
        dir_path, file_name = os.path.split(request_file_path)
        new_file_name = None
        SUFFIX_REQUEST = "request.json"
        SUFFIX_RESPONSE = "response.json"
        if file_name.lower().endswith(SUFFIX_REQUEST):
            temp = file_name.lower().split(
                SUFFIX_REQUEST)[0]
            new_file_name = file_name[:len(temp)] + SUFFIX_RESPONSE
        else:
            new_file_name = file_name + '_' + SUFFIX_RESPONSE
        return dir_path + '/' + new_file_name
